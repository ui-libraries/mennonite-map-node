"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["perArrowheadOptions"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function modulus(i, n) {
  return (i % n + n) % n;
}
function definedProps(obj) {
  return Object.fromEntries(Object.entries(obj).filter(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      k = _ref2[0],
      v = _ref2[1];
    return v !== undefined;
  }));
}

/**
 * Whether or not a string is in the format '<number>m'
 * @param {string} value
 * @returns Boolean
 */
function isInMeters(value) {
  return value.toString().trim().slice(value.toString().length - 1, value.toString().length) === 'm';
}

/**
 * Whether or not a string is in the format '<number>%'
 * @param {string} value
 * @returns Boolean
 */
function isInPercent(value) {
  return value.toString().trim().slice(value.toString().length - 1, value.toString().length) === '%';
}

/**
 * Whether or not a string is in the format '<number>px'
 * @param {string} value
 * @returns Boolean
 */
function isInPixels(value) {
  return value.toString().trim().slice(value.toString().length - 2, value.toString().length) === 'px';
}
function pixelsToMeters(pixels, map) {
  var refPoint1 = map.getCenter();
  var xy1 = map.latLngToLayerPoint(refPoint1);
  var xy2 = {
    x: xy1.x + Number(pixels),
    y: xy1.y
  };
  var refPoint2 = map.layerPointToLatLng(xy2);
  var derivedMeters = map.distance(refPoint1, refPoint2);
  return derivedMeters;
}
L.Polyline.include({
  /**
   * Adds arrowheads to an L.polyline
   * @param {object} options The options for the arrowhead.  See documentation for details
   * @returns The L.polyline instance that they arrowheads are attached to
   */
  arrowheads: function arrowheads() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // Merge user input options with default options:
    var defaults = {
      yawn: 60,
      size: '15%',
      frequency: 'allvertices',
      proportionalToTotal: false
    };
    this.options.noClip = true;
    var actualOptions = Object.assign({}, defaults, options);
    this._arrowheadOptions = actualOptions;
    this._hatsApplied = true;
    return this;
  },
  buildVectorHats: function buildVectorHats(options) {
    var _this = this;
    // Reset variables from previous this._update()
    if (this._arrowheads) {
      this._arrowheads.remove();
    }
    if (this._ghosts) {
      this._ghosts.remove();
    }

    //  -------------------------------------------------------- //
    //  ------------  FILTER THE OPTIONS ----------------------- //
    /*
     * The next 3 lines folds the options of the parent polyline into the default options for all polylines
     * The options for the arrowhead are then folded in as well
     * All options defined in parent polyline will be inherited by the arrowhead, unless otherwise specified in the arrowhead(options) call
     */

    var defaultOptionsOfParent = Object.getPrototypeOf(Object.getPrototypeOf(this.options));

    // merge default options of parent polyline (this.options's prototype's prototype) with options passed to parent polyline (this.options).
    var parentOptions = Object.assign({}, defaultOptionsOfParent, this.options);

    // now merge in the options the user has put in the arrowhead call
    var hatOptions = Object.assign({}, parentOptions, options);

    // ...with a few exceptions:
    hatOptions.smoothFactor = 1;
    hatOptions.fillOpacity = 1;
    hatOptions.fill = options.fill ? true : false;
    hatOptions.interactive = false;

    //  ------------  FILTER THE OPTIONS END -------------------- //
    //  --------------------------------------------------------- //

    //  --------------------------------------------------------- //
    //  ------ LOOP THROUGH EACH POLYLINE SEGMENT --------------- //
    //  ------ TO CALCULATE HAT SIZES AND CAPTURE IN ARRAY ------ //

    var size = options.size.toString(); // stringify if its a number
    var allhats = []; // empty array to receive hat polylines
    var frequency = options.frequency,
      offsets = options.offsets;
    if (offsets !== null && offsets !== void 0 && offsets.start || offsets !== null && offsets !== void 0 && offsets.end) {
      this._buildGhosts({
        start: offsets.start,
        end: offsets.end
      });
    }
    var lineToTrace = this._ghosts || this;
    lineToTrace._parts.forEach(function (peice, index) {
      // Immutable variables for each peice
      var latlngs = peice.map(function (point) {
        return _this._map.layerPointToLatLng(point);
      });
      var totalLength = function () {
        var total = 0;
        for (var i = 0; i < peice.length - 1; i++) {
          total += _this._map.distance(latlngs[i], latlngs[i + 1]);
        }
        return total;
      }();

      // TBD by options if tree below
      var derivedLatLngs;
      var derivedBearings;
      var spacing;
      var noOfPoints;

      //  Determining latlng and bearing arrays based on frequency choice:
      if (!isNaN(frequency)) {
        spacing = 1 / frequency;
        noOfPoints = frequency;
      } else if (isInPercent(frequency)) {
        console.error('Error: arrowhead frequency option cannot be given in percent.  Try another unit.');
      } else if (isInMeters(frequency)) {
        spacing = frequency.slice(0, frequency.length - 1) / totalLength;
        noOfPoints = 1 / spacing;
        // round things out for more even spacing:
        noOfPoints = Math.floor(noOfPoints);
        spacing = 1 / noOfPoints;
      } else if (isInPixels(frequency)) {
        spacing = function () {
          var chosenFrequency = frequency.slice(0, frequency.length - 2);
          var derivedMeters = pixelsToMeters(chosenFrequency, _this._map);
          return derivedMeters / totalLength;
        }();
        noOfPoints = 1 / spacing;

        // round things out for more even spacing:
        noOfPoints = Math.floor(noOfPoints);
        spacing = 1 / noOfPoints;
      }
      if (options.frequency === 'allvertices') {
        derivedBearings = function () {
          var bearings = [];
          for (var i = 1; i < latlngs.length; i++) {
            var bearing = L.GeometryUtil.angle(_this._map, latlngs[modulus(i - 1, latlngs.length)], latlngs[i]) + 180;
            bearings.push(bearing);
          }
          return bearings;
        }();
        derivedLatLngs = latlngs;
        derivedLatLngs.shift();
      } else if (options.frequency === 'endonly' && latlngs.length >= 2) {
        derivedLatLngs = [latlngs[latlngs.length - 1]];
        derivedBearings = [L.GeometryUtil.angle(_this._map, latlngs[latlngs.length - 2], latlngs[latlngs.length - 1]) + 180];
      } else {
        derivedLatLngs = [];
        var interpolatedPoints = [];
        for (var i = 0; i < noOfPoints; i++) {
          var interpolatedPoint = L.GeometryUtil.interpolateOnLine(_this._map, latlngs, spacing * (i + 1));
          if (interpolatedPoint) {
            interpolatedPoints.push(interpolatedPoint);
            derivedLatLngs.push(interpolatedPoint.latLng);
          }
        }
        derivedBearings = function () {
          var bearings = [];
          for (var i = 0; i < interpolatedPoints.length; i++) {
            var bearing = L.GeometryUtil.angle(_this._map, latlngs[interpolatedPoints[i].predecessor + 1], latlngs[interpolatedPoints[i].predecessor]);
            bearings.push(bearing);
          }
          return bearings;
        }();
      }
      var hats = [];

      // Function to build hats based on index and a given hatsize in meters
      var pushHats = function pushHats(size) {
        var _localHatOptions$yawn;
        var localHatOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var yawn = (_localHatOptions$yawn = localHatOptions.yawn) !== null && _localHatOptions$yawn !== void 0 ? _localHatOptions$yawn : options.yawn;
        var leftWingPoint = L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] - yawn / 2, size);
        var rightWingPoint = L.GeometryUtil.destination(derivedLatLngs[i], derivedBearings[i] + yawn / 2, size);
        var hatPoints = [[leftWingPoint.lat, leftWingPoint.lng], [derivedLatLngs[i].lat, derivedLatLngs[i].lng], [rightWingPoint.lat, rightWingPoint.lng]];
        var hat = options.fill ? L.polygon(hatPoints, _objectSpread(_objectSpread({}, hatOptions), localHatOptions)) : L.polyline(hatPoints, _objectSpread(_objectSpread({}, hatOptions), localHatOptions));
        hats.push(hat);
      }; // pushHats()

      // Function to build hats based on pixel input
      var pushHatsFromPixels = function pushHatsFromPixels(size) {
        var _localHatOptions$yawn2;
        var localHatOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var sizePixels = size.slice(0, size.length - 2);
        var yawn = (_localHatOptions$yawn2 = localHatOptions.yawn) !== null && _localHatOptions$yawn2 !== void 0 ? _localHatOptions$yawn2 : options.yawn;
        var derivedXY = _this._map.latLngToLayerPoint(derivedLatLngs[i]);
        var bearing = derivedBearings[i];
        var thetaLeft = (180 - bearing - yawn / 2) * (Math.PI / 180),
          thetaRight = (180 - bearing + yawn / 2) * (Math.PI / 180);
        var dxLeft = sizePixels * Math.sin(thetaLeft),
          dyLeft = sizePixels * Math.cos(thetaLeft),
          dxRight = sizePixels * Math.sin(thetaRight),
          dyRight = sizePixels * Math.cos(thetaRight);
        var leftWingXY = {
          x: derivedXY.x + dxLeft,
          y: derivedXY.y + dyLeft
        };
        var rightWingXY = {
          x: derivedXY.x + dxRight,
          y: derivedXY.y + dyRight
        };
        var leftWingPoint = _this._map.layerPointToLatLng(leftWingXY),
          rightWingPoint = _this._map.layerPointToLatLng(rightWingXY);
        var hatPoints = [[leftWingPoint.lat, leftWingPoint.lng], [derivedLatLngs[i].lat, derivedLatLngs[i].lng], [rightWingPoint.lat, rightWingPoint.lng]];
        var hat = options.fill ? L.polygon(hatPoints, _objectSpread(_objectSpread({}, hatOptions), localHatOptions)) : L.polyline(hatPoints, _objectSpread(_objectSpread({}, hatOptions), localHatOptions));
        hats.push(hat);
      }; // pushHatsFromPixels()

      //  -------  LOOP THROUGH POINTS IN EACH SEGMENT ---------- //
      var _loop = function _loop() {
        var _perArrowheadOptions$;
        var perArrowheadOptions = options.perArrowheadOptions,
          globalOptions = _objectWithoutProperties(options, _excluded);
        perArrowheadOptions = perArrowheadOptions ? perArrowheadOptions(i) : {};
        perArrowheadOptions = Object.assign(globalOptions, definedProps(perArrowheadOptions));
        size = (_perArrowheadOptions$ = perArrowheadOptions.size) !== null && _perArrowheadOptions$ !== void 0 ? _perArrowheadOptions$ : size;

        // ---- If size is chosen in meters -------------------------
        if (isInMeters(size)) {
          var hatSize = size.slice(0, size.length - 1);
          pushHats(hatSize, perArrowheadOptions);

          // ---- If size is chosen in percent ------------------------
        } else if (isInPercent(size)) {
          var sizePercent = size.slice(0, size.length - 1);
          var _hatSize = function () {
            if (options.frequency === 'endonly' && options.proportionalToTotal) {
              return totalLength * sizePercent / 100;
            } else {
              var averageDistance = totalLength / (peice.length - 1);
              return averageDistance * sizePercent / 100;
            }
          }(); // hatsize calculation

          pushHats(_hatSize, perArrowheadOptions);

          // ---- If size is chosen in pixels --------------------------
        } else if (isInPixels(size)) {
          pushHatsFromPixels(options.size, perArrowheadOptions);

          // ---- If size unit is not given -----------------------------
        } else {
          console.error('Error: Arrowhead size unit not defined.  Check your arrowhead options.');
        } // if else block for Size
      };
      for (var i = 0; i < derivedLatLngs.length; i++) {
        _loop();
      } // for loop for each point witin a peice

      allhats.push.apply(allhats, hats);
    }); // forEach peice

    //  --------- LOOP THROUGH EACH POLYLINE END ---------------- //
    //  --------------------------------------------------------- //

    var arrowheads = L.layerGroup(allhats);
    this._arrowheads = arrowheads;
    return this;
  },
  getArrowheads: function getArrowheads() {
    if (this._arrowheads) {
      return this._arrowheads;
    } else {
      return console.error("Error: You tried to call '.getArrowheads() on a shape that does not have a arrowhead.  Use '.arrowheads()' to add a arrowheads before trying to call '.getArrowheads()'");
    }
  },
  /**
   * Builds ghost polylines that are clipped versions of the polylines based on the offsets
   * If offsets are used, arrowheads are drawn from 'this._ghosts' rather than 'this'
   */
  _buildGhosts: function _buildGhosts(_ref3) {
    var _this2 = this;
    var start = _ref3.start,
      end = _ref3.end;
    if (start || end) {
      var latlngs = this.getLatLngs();
      latlngs = Array.isArray(latlngs[0]) ? latlngs : [latlngs];
      var newLatLngs = latlngs.map(function (segment) {
        // Get total distance of original latlngs
        var totalLength = function () {
          var total = 0;
          for (var i = 0; i < segment.length - 1; i++) {
            total += _this2._map.distance(segment[i], segment[i + 1]);
          }
          return total;
        }();

        // Modify latlngs to end at interpolated point
        if (start) {
          var endOffsetInMeters = function () {
            if (isInMeters(start)) {
              return Number(start.slice(0, start.length - 1));
            } else if (isInPixels(start)) {
              var pixels = Number(start.slice(0, start.length - 2));
              return pixelsToMeters(pixels, _this2._map);
            }
          }();
          var newStart = L.GeometryUtil.interpolateOnLine(_this2._map, segment, endOffsetInMeters / totalLength);
          segment = segment.slice(newStart.predecessor === -1 ? 1 : newStart.predecessor + 1, segment.length);
          segment.unshift(newStart.latLng);
        }
        if (end) {
          var _endOffsetInMeters = function () {
            if (isInMeters(end)) {
              return Number(end.slice(0, end.length - 1));
            } else if (isInPixels(end)) {
              var pixels = Number(end.slice(0, end.length - 2));
              return pixelsToMeters(pixels, _this2._map);
            }
          }();
          var newEnd = L.GeometryUtil.interpolateOnLine(_this2._map, segment, (totalLength - _endOffsetInMeters) / totalLength);
          segment = segment.slice(0, newEnd.predecessor + 1);
          segment.push(newEnd.latLng);
        }
        return segment;
      });
      this._ghosts = L.polyline(newLatLngs, _objectSpread(_objectSpread({}, this.options), {}, {
        color: 'rgba(0,0,0,0)',
        stroke: 0,
        smoothFactor: 0,
        interactive: false
      }));
      this._ghosts.addTo(this._map);
    }
  },
  deleteArrowheads: function deleteArrowheads() {
    if (this._arrowheads) {
      this._arrowheads.remove();
      delete this._arrowheads;
      delete this._arrowheadOptions;
      this._hatsApplied = false;
    }
    if (this._ghosts) {
      this._ghosts.remove();
    }
  },
  _update: function _update() {
    if (!this._map) {
      return;
    }
    this._clipPoints();
    this._simplifyPoints();
    this._updatePath();
    if (this._hatsApplied) {
      this.buildVectorHats(this._arrowheadOptions);
      this._map.addLayer(this._arrowheads);
    }
  },
  remove: function remove() {
    if (this._arrowheads) {
      this._arrowheads.remove();
    }
    if (this._ghosts) {
      this._ghosts.remove();
    }
    return this.removeFrom(this._map || this._mapToAdd);
  }
});
L.LayerGroup.include({
  removeLayer: function removeLayer(layer) {
    var id = layer in this._layers ? layer : this.getLayerId(layer);
    if (this._map && this._layers[id]) {
      if (this._layers[id]._arrowheads) {
        this._layers[id]._arrowheads.remove();
      }
      this._map.removeLayer(this._layers[id]);
    }
    delete this._layers[id];
    return this;
  },
  onRemove: function onRemove(map, layer) {
    for (var layer in this._layers) {
      if (this._layers[layer]) {
        this._layers[layer].remove();
      }
    }
    this.eachLayer(map.removeLayer, map);
  }
});
L.Map.include({
  removeLayer: function removeLayer(layer) {
    var id = L.Util.stamp(layer);
    if (layer._arrowheads) {
      layer._arrowheads.remove();
    }
    if (layer._ghosts) {
      layer._ghosts.remove();
    }
    if (!this._layers[id]) {
      return this;
    }
    if (this._loaded) {
      layer.onRemove(this);
    }
    if (layer.getAttribution && this.attributionControl) {
      this.attributionControl.removeAttribution(layer.getAttribution());
    }
    delete this._layers[id];
    if (this._loaded) {
      this.fire('layerremove', {
        layer: layer
      });
      layer.fire('remove');
    }
    layer._map = layer._mapToAdd = null;
    return this;
  }
});
L.GeoJSON.include({
  geometryToLayer: function geometryToLayer(geojson, options) {
    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
      coords = geometry ? geometry.coordinates : null,
      layers = [],
      pointToLayer = options && options.pointToLayer,
      _coordsToLatLng = options && options.coordsToLatLng || L.GeoJSON.coordsToLatLng,
      latlng,
      latlngs,
      i,
      len;
    if (!coords && !geometry) {
      return null;
    }
    switch (geometry.type) {
      case 'Point':
        latlng = _coordsToLatLng(coords);
        return this._pointToLayer(pointToLayer, geojson, latlng, options);
      case 'MultiPoint':
        for (i = 0, len = coords.length; i < len; i++) {
          latlng = _coordsToLatLng(coords[i]);
          layers.push(this._pointToLayer(pointToLayer, geojson, latlng, options));
        }
        return new L.FeatureGroup(layers);
      case 'LineString':
      case 'MultiLineString':
        latlngs = L.GeoJSON.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
        var polyline = new L.Polyline(latlngs, options);
        if (options.arrowheads) {
          polyline.arrowheads(options.arrowheads);
        }
        return polyline;
      case 'Polygon':
      case 'MultiPolygon':
        latlngs = L.GeoJSON.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
        return new L.Polygon(latlngs, options);
      case 'GeometryCollection':
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          var layer = this.geometryToLayer({
            geometry: geometry.geometries[i],
            type: 'Feature',
            properties: geojson.properties
          }, options);
          if (layer) {
            layers.push(layer);
          }
        }
        return new L.FeatureGroup(layers);
      default:
        throw new Error('Invalid GeoJSON object.');
    }
  },
  addData: function addData(geojson) {
    var features = L.Util.isArray(geojson) ? geojson : geojson.features,
      i,
      len,
      feature;
    if (features) {
      for (i = 0, len = features.length; i < len; i++) {
        // only add this if geometry or geometries are set and not null
        feature = features[i];
        if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
          this.addData(feature);
        }
      }
      return this;
    }
    var options = this.options;
    if (options.filter && !options.filter(geojson)) {
      return this;
    }
    var layer = this.geometryToLayer(geojson, options);
    if (!layer) {
      return this;
    }
    layer.feature = L.GeoJSON.asFeature(geojson);
    layer.defaultOptions = layer.options;
    this.resetStyle(layer);
    if (options.onEachFeature) {
      options.onEachFeature(geojson, layer);
    }
    return this.addLayer(layer);
  },
  _pointToLayer: function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new L.Marker(latlng, options && options.markersInheritOptions && options);
  }
});